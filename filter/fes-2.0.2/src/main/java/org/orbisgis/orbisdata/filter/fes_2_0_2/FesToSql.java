/**
 * OrbisGIS is a java GIS application dedicated to research in GIScience.
 * OrbisGIS is developed by the GIS group of the DECIDE team of the
 * Lab-STICC CNRS laboratory, see <http://www.lab-sticc.fr/>.
 *
 * The GIS group of the DECIDE team is located at :
 *
 * Laboratoire Lab-STICC – CNRS UMR 6285
 * Equipe DECIDE
 * UNIVERSITÉ DE BRETAGNE-SUD
 * Institut Universitaire de Technologie de Vannes
 * 8, Rue Montaigne - BP 561 56017 Vannes Cedex
 *
 * OrbisGIS is distributed under GPL 3 license.
 *
 * Copyright (C) 2015-2017 CNRS (Lab-STICC UMR CNRS 6285)
 *
 * This file is part of OrbisGIS.
 *
 * OrbisGIS is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OrbisGIS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OrbisGIS. If not, see <http://www.gnu.org/licenses/>.
 *
 * For more information, please consult: <http://www.orbisgis.org/>
 * or contact directly:
 * info_at_ orbisgis.org
 */
package org.orbisgis.orbisdata.filter.fes_2_0_2;

import net.opengis.fes._2_0_2.*;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import java.util.Iterator;
import java.util.List;


/**
 * This class change a JaxB object in SQL parameter.
 * @Author Vincent QUILLIEN
 */
public class FesToSql {

    /**
     * This method take an object generated by JaxB from a xml file and give un return the SQL parameter.
     * @param objectFromFilterXml
     * @return the SQL parameter
     * @throws JAXBException
     */
    public static StringBuilder XmlToSql(Object objectFromFilterXml ){
        StringBuilder returnSQL = new StringBuilder();
        if (objectFromFilterXml instanceof JAXBElement) {
            // first node : One branch for Filter and one for SortBy
            switch (((JAXBElement) objectFromFilterXml).getName().getLocalPart()) {
                case "Filter":
                    FilterType filterType = (FilterType) ((JAXBElement) objectFromFilterXml).getValue();
                    // know the type of operator
                    if (filterType.isSetComparisonOps()) {
                        JAXBElement<ComparisonOpsType> comparisonElement = (JAXBElement<ComparisonOpsType>) filterType.getComparisonOps();
                        if (comparisonElement.getName().getLocalPart() == "PropertyIsBetween") {
                            PropertyIsBetweenType propertyIsBetweenType = (PropertyIsBetweenType) comparisonElement.getValue();
                            JAXBElement lowerBoundary = propertyIsBetweenType.getLowerBoundary().getExpression();
                            JAXBElement upperBoundary = propertyIsBetweenType.getUpperBoundary().getExpression();
                            if (propertyIsBetweenType.isSetExpression()) {
                                returnSQL.append(getExpressionRecursive(propertyIsBetweenType.getExpression()));
                                returnSQL.append("BETWEEN");
                                if (propertyIsBetweenType.isSetLowerBoundary())
                                    returnSQL.append(getExpressionRecursive(lowerBoundary));
                                if (propertyIsBetweenType.isSetUpperBoundary())
                                    returnSQL.append(getExpressionRecursive(upperBoundary));
                            } else returnSQL.append("The column isn't defined");

                        } else if (comparisonElement.getName().getLocalPart() == "PropertyIsLike") {
                            PropertyIsLikeType propertyIsLikeType = (PropertyIsLikeType) comparisonElement.getValue();
                            if (propertyIsLikeType.isSetExpression()) {
                                List<JAXBElement<?>> list = propertyIsLikeType.getExpression();
                                for (JAXBElement element : list) {
                                    returnSQL.append(getExpressionRecursive(element));
                                    if (list.get(0) == element) {
                                        returnSQL.append("LIKE");
                                    }
                                }
                            }
                        } else if (comparisonElement.getName().getLocalPart() == "PropertyIsNil") {
                            PropertyIsNilType propertyIsNilType = (PropertyIsNilType) comparisonElement.getValue();
                            if (propertyIsNilType.isSetExpression()) {
                                returnSQL.append(getExpressionRecursive(propertyIsNilType.getExpression()));
                                returnSQL.append("IS NIL");
                            }

                        } else if (comparisonElement.getName().getLocalPart() == "PropertyIsNull") {
                            PropertyIsNullType propertyIsNullType = (PropertyIsNullType) comparisonElement.getValue();
                            if (propertyIsNullType.isSetExpression()) {
                                returnSQL.append(getExpressionRecursive(propertyIsNullType.getExpression()));
                                returnSQL.append("IS NULL");
                            }

                        } else {//type BinaryComparisonOpType
                            BinaryComparisonOpType binaryComparisonOpType = (BinaryComparisonOpType) comparisonElement.getValue();
                            if (binaryComparisonOpType.isSetExpression()) {
                                List<JAXBElement<?>> list = binaryComparisonOpType.getExpression();
                                for (JAXBElement element : list) {
                                    returnSQL.append(getExpressionRecursive(element));
                                    if (list.get(0) == element) {
                                        switch (comparisonElement.getName().getLocalPart()){
                                            case "PropertyIsGreaterThan":
                                                returnSQL.append(">");
                                                break;
                                            case "PropertyIsLessThan":
                                                returnSQL.append("<");
                                                break;
                                            case "PropertyEqualTo":
                                                returnSQL.append("=");
                                                break;
                                            case "PropertyIsNotEqualTo":
                                                returnSQL.append("!=");
                                                break;
                                            case "PropertyIsLessThanOrEqualTo":
                                                returnSQL.append("<=");
                                                break;
                                            case "PropertyIsGreaterThanOrEqualTo":
                                                returnSQL.append(">=");
                                                break;
                                        }
                                    }
                                }
                            }
                        }
                    } else if (filterType.isSetLogicOps()) {
                        JAXBElement<LogicOpsType> logicalElement = (JAXBElement<LogicOpsType>) filterType.getLogicOps();
                        if (logicalElement.getName().getLocalPart() == "Not") {
                            UnaryLogicOpType unaryLogicOpType = (UnaryLogicOpType) logicalElement.getValue();
                        } else {
                            BinaryLogicOpType binaryLogicOpType = (BinaryLogicOpType) logicalElement.getValue();

                        }
                    } else if (filterType.isSetSpatialOps()) {
                        //to add after

                    } else if (filterType.isSetFunction()) {
                        //to add after

                    } else if (filterType.isSetId()) {
                        //to add after

                    } else if (filterType.isSetExtensionOps()) {
                        //to add after

                    } else if (filterType.isSetTemporalOps()) {
                        //not required
                    }
                    break;

            case "SortBy":

                SortByType sortByType = (SortByType) ((JAXBElement) objectFromFilterXml).getValue();
                if (sortByType.isSetSortProperty()) {
                    List<SortPropertyType> listProperty = sortByType.getSortProperty();
                    Iterator<SortPropertyType> listPropertyIterator = listProperty.iterator();
                    while (listPropertyIterator.hasNext()) {
                        SortPropertyType property = listPropertyIterator.next();

                        if (listPropertyIterator.hasNext() && property.isSetSortOrder()) {

                            returnSQL.append(property.getValueReference());
                            returnSQL.append(property.getSortOrder().value() + ", ");

                        } else if (listPropertyIterator.hasNext() && !(property.isSetSortOrder())) {

                            returnSQL.append(property.getValueReference() + ", ");

                        } else if (!(listPropertyIterator.hasNext()) && (property.isSetSortOrder())) {

                            returnSQL.append(property.getValueReference() + " ");
                            returnSQL.append(property.getSortOrder());
                        } else {
                            returnSQL.append(property.getValueReference());
                        }
                    }
                }
                break;

        }
    }
    return returnSQL;
}


    private static StringBuilder getExpressionRecursive(JAXBElement element){
        StringBuilder stringBuilder = new StringBuilder();
        if(element.getName().getLocalPart()=="Function"){
            FunctionType functionType = (FunctionType) element.getValue();
            stringBuilder.append(functionType.getName()+"( ");

            List<JAXBElement<?>> listExpression = functionType.getExpression();
            for(JAXBElement exp : listExpression){
                getExpressionRecursive(exp);
            }
        }else if(element.getName().getLocalPart()=="ValueReference"){
            stringBuilder.append(""+element.getValue().toString()+" ");

        }else if(element.getName().getLocalPart()=="Literal"){
            element = (JAXBElement<LiteralType>) element;
            LiteralType literalType = (LiteralType) element.getValue();
            List list = literalType.getContent();
            for(Object obj : list){
                stringBuilder.append(" "+obj.toString()+" ");
            }
        }else{
            stringBuilder.append(element.getValue().toString());
        }
        return stringBuilder;
    }
}
